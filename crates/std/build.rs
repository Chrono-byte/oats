//! Build script for oats_std
//!
//! This script automatically generates Oats type definitions (.d.ts files)
//! from the Rust source code by parsing #[oats_export] attributes.

use std::fs;
use std::path::Path;

fn main() {
    // Create dist directory
    fs::create_dir_all("dist").expect("Failed to create dist directory");

    // Parse the source files and generate type definitions
    let type_defs = generate_type_definitions();

    // Write the type definitions to dist/lib.oats.d.ts
    fs::write("dist/lib.oats.d.ts", type_defs).expect("Failed to write type definitions");

    // Tell cargo to rerun this script if any source files change
    println!("cargo:rerun-if-changed=src/");
}

fn generate_type_definitions() -> String {
    let mut output = String::new();

    // Header
    output.push_str("// Auto-generated Oats standard library type definitions\n");
    output.push_str("// Do not edit manually - generated by build.rs\n\n");

    // Parse source files for exports
    let modules = vec![
        ("console", "src/console.rs"),
        ("fs", "src/fs.rs"),
        ("process", "src/process.rs"),
        ("path", "src/path.rs"),
        ("net", "src/net.rs"),
        ("env", "src/env.rs"),
        ("time", "src/time.rs"),
    ];

    for (module_name, file_path) in modules {
        if Path::new(file_path).exists() {
            if let Ok(content) = fs::read_to_string(file_path) {
                let module_defs = parse_module(&content, module_name);
                if !module_defs.is_empty() {
                    output.push_str(&format!("declare namespace {} {{\n", module_name));
                    output.push_str(&module_defs);
                    output.push_str("}\n\n");
                }
            }
        }
    }

    // Add global types
    output.push_str("// Global types\n");
    output.push_str("declare interface Array<T> {\n");
    output.push_str("    length: number;\n");
    output.push_str("    push(item: T): number;\n");
    output.push_str("    pop(): T | undefined;\n");
    output.push_str("    map<U>(callback: (item: T, index: number) => U): U[];\n");
    output.push_str("    filter(callback: (item: T, index: number) => boolean): T[];\n");
    output.push_str("    forEach(callback: (item: T, index: number) => void): void;\n");
    output.push_str("}\n\n");

    output.push_str("declare interface String {\n");
    output.push_str("    length: number;\n");
    output.push_str("    charAt(index: number): string;\n");
    output.push_str("    substring(start: number, end?: number): string;\n");
    output.push_str("    split(separator: string): string[];\n");
    output.push_str("    replace(search: string, replacement: string): string;\n");
    output.push_str("}\n\n");

    output
}

fn parse_module(content: &str, _module_name: &str) -> String {
    let mut output = String::new();

    // Simple parsing for #[oats_export] attributes
    // This is a basic implementation - a real version would use syn for proper AST parsing
    let lines: Vec<&str> = content.lines().collect();

    for (i, line) in lines.iter().enumerate() {
        if line.contains("/// #[oats_export]") {
            // Look for the function signature in the next few lines
            for j in (i + 1)..lines.len().min(i + 10) {
                let func_line = lines[j].trim();
                if func_line.starts_with("pub extern \"C\" fn ") || func_line.starts_with("extern \"C\" fn ") {
                    if let Some(func_def) = parse_function_signature(func_line) {
                        output.push_str(&func_def);
                        output.push_str("\n");
                    }
                    break;
                }
            }
        }
    }

    output
}

fn parse_function_signature(line: &str) -> Option<String> {
    // Very basic function signature parsing
    // Format: fn function_name(param1: Type1, param2: Type2) -> ReturnType

    let line = line.trim();
    if !line.starts_with("fn ") {
        return None;
    }

    let after_fn = &line[3..];
    let paren_pos = after_fn.find('(')?;
    let func_name = after_fn[..paren_pos].trim();

    let after_paren = &after_fn[paren_pos + 1..];
    let close_paren_pos = after_paren.find(')')?;
    let params_str = &after_paren[..close_paren_pos];

    // Parse return type
    let return_type = if after_paren[close_paren_pos + 1..].trim().starts_with("->") {
        let return_part = &after_paren[close_paren_pos + 1..].trim();
        if return_part.starts_with("-> ") {
            return_part[3..].trim()
        } else {
            "void"
        }
    } else {
        "void"
    };

    // Parse parameters
    let params: Vec<&str> = params_str.split(',').map(|p| p.trim()).collect();
    let mut ts_params = Vec::new();

    for param in params {
        if param.is_empty() {
            continue;
        }
        let parts: Vec<&str> = param.split(':').map(|p| p.trim()).collect();
        if parts.len() == 2 {
            let param_name = parts[0];
            let param_type = rust_type_to_oats_type(parts[1]);
            ts_params.push(format!("{}: {}", param_name, param_type));
        }
    }

    let ts_return = rust_type_to_oats_type(return_type);

    Some(format!("    function {}({}): {};", func_name, ts_params.join(", "), ts_return))
}

fn rust_type_to_oats_type(rust_type: &str) -> &str {
    match rust_type {
        "OatsString" => "string",
        "i32" | "i64" | "f32" | "f64" => "number",
        "bool" => "boolean",
        "()" | "void" => "void",
        "OatsArray" => "any[]",
        _ => "any",
    }
}