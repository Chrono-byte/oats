//! Build script for oats_std
//!
//! This script automatically generates Oats type definitions (.d.ts files)
//! from the Rust source code by parsing #[oats_export] attributes.

use std::fs;
use std::path::Path;

fn main() {
    // Create dist directory
    fs::create_dir_all("dist").expect("Failed to create dist directory");

    // Parse the source files and generate type definitions
    let type_defs = generate_type_definitions();

    // Write the type definitions to dist/lib.d.oats
    fs::write("dist/lib.d.oats", type_defs).expect("Failed to write type definitions");

    // Tell cargo to rerun this script if any source files change
    println!("cargo:rerun-if-changed=src/");
}

fn generate_type_definitions() -> String {
    let mut output = String::new();

    // Header
    output.push_str("// Auto-generated Oats standard library type definitions\n");
    output.push_str("// Do not edit manually - generated by build.rs\n\n");

    // Parse source files for exports
    let modules = vec![
        ("console", "src/console.rs"),
        ("fs", "src/fs.rs"),
        ("process", "src/process.rs"),
        ("actor", "src/actor.rs"),
        ("path", "src/path.rs"),
        ("net", "src/net.rs"),
        ("env", "src/env.rs"),
        ("temporal", "src/temporal.rs"),
        ("time", "src/time.rs"),
    ];

    for (module_name, file_path) in modules {
        if Path::new(file_path).exists()
            && let Ok(content) = fs::read_to_string(file_path)
        {
            let module_defs = parse_module(&content, module_name);
            if !module_defs.is_empty() {
                output.push_str(&format!("declare namespace {} {{\n", module_name));
                output.push_str(&module_defs);
                output.push_str("}\n\n");
            }
        }
    }

    // Add global types
    output.push_str("// Global types\n");
    output.push_str("declare interface Array<T> {\n");
    output.push_str("    length: number;\n");
    output.push_str("    push(item: T): number;\n");
    output.push_str("    pop(): T | undefined;\n");
    output.push_str("    map<U>(callback: (item: T, index: number) => U): U[];\n");
    output.push_str("    filter(callback: (item: T, index: number) => boolean): T[];\n");
    output.push_str("    forEach(callback: (item: T, index: number) => void): void;\n");
    output.push_str("}\n\n");

    output.push_str("declare interface String {\n");
    output.push_str("    length: number;\n");
    output.push_str("    charAt(index: number): string;\n");
    output.push_str("    substring(start: number, end?: number): string;\n");
    output.push_str("    split(separator: string): string[];\n");
    output.push_str("    replace(search: string, replacement: string): string;\n");
    output.push_str("}\n\n");

    output
}

fn parse_module(content: &str, _module_name: &str) -> String {
    let mut output = String::new();

    // Simple parsing for #[oats_export] attributes
    // This is a basic implementation - a real version would use syn for proper AST parsing
    let lines: Vec<&str> = content.lines().collect();

    for (i, line) in lines.iter().enumerate() {
        if line.contains("/// #[oats_export]") {
            // Look for the function signature in the next few lines
            for func_line in lines.iter().skip(i + 1).take(10).map(|l| l.trim()) {
                if func_line.starts_with("#[no_mangle]") {
                    // Skip the no_mangle attribute
                    continue;
                }
                if func_line.starts_with("pub extern \"C\" fn ")
                    || func_line.starts_with("extern \"C\" fn ")
                {
                    if let Some(func_def) = parse_function_signature(func_line) {
                        output.push_str(&func_def);
                        output.push('\n');
                    }
                    break;
                }
            }
        }
    }

    output
}

fn parse_function_signature(line: &str) -> Option<String> {
    // Very basic function signature parsing
    // Format: [pub] extern "C" fn function_name(param1: Type1, param2: Type2) -> ReturnType

    let line = line.trim();
    let fn_start = if line.starts_with("pub extern \"C\" fn ") {
        "pub extern \"C\" fn "
    } else if line.starts_with("extern \"C\" fn ") {
        "extern \"C\" fn "
    } else if line.starts_with("fn ") {
        "fn "
    } else {
        return None;
    };

    let after_fn = &line[fn_start.len()..];
    let paren_pos = after_fn.find('(')?;
    let func_name = after_fn[..paren_pos].trim();

    let after_paren = &after_fn[paren_pos + 1..];
    let close_paren_pos = after_paren.find(')')?;
    let params_str = &after_paren[..close_paren_pos];

    // Parse return type
    let return_type = if after_paren[close_paren_pos + 1..].trim().starts_with("->") {
        let return_part = &after_paren[close_paren_pos + 1..].trim();
        if let Some(stripped) = return_part.strip_prefix("-> ") {
            stripped.trim()
        } else {
            "void"
        }
    } else {
        "void"
    };

    // Parse parameters
    let params: Vec<&str> = params_str.split(',').map(|p| p.trim()).collect();
    let mut ts_params = Vec::new();

    for param in params {
        if param.is_empty() {
            continue;
        }
        let colon_pos = param.find(':')?;
        let param_name = param[..colon_pos].trim();
        let param_type = param[colon_pos + 1..].trim();
        let ts_type = rust_type_to_oats_type(param_type);
        ts_params.push(format!("{}: {}", param_name, ts_type));
    }

    let ts_return = rust_type_to_oats_type(return_type);
    let func_def = format!(
        "function {}({}): {};",
        func_name,
        ts_params.join(", "),
        ts_return
    );
    Some(func_def)
}

fn rust_type_to_oats_type(rust_type: &str) -> &str {
    match rust_type {
        "OatsString" => "string",
        "i32" | "i64" | "f32" | "f64" | "c_longlong" => "number",
        "bool" => "boolean",
        "()" | "void" => "void",
        "OatsArray" => "any[]",
        _ => "any",
    }
}
